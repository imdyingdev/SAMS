import datetime
import json
from typing import Dict, List, Optional, Tuple
from enum import Enum
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class AttendanceStatus(Enum):
    PRESENT = "present"
    LATE = "late"
    SO_LATE = "so-late"
    ABSENT = "absent"
    EXCUSE = "excuse"
    TIMEOUT = "timeout"

class RFIDLogError(Exception):
    """Custom exception for RFID log errors"""
    pass

class AttendanceSchedule:
    """Class to handle schedule configurations"""
    def __init__(self):
        self.work_start = datetime.time(8, 0)  # 8:00 AM
        self.work_end = datetime.time(17, 0)   # 5:00 PM
        self.late_threshold = 15  # minutes
        self.so_late_threshold = 60  # minutes
        self.timeout_duration = 30  # minutes minimum between scans
        self.grace_period = 5  # minutes grace period for early timeout

class UserSession:
    """Track user session state"""
    def __init__(self, user_id: str):
        self.user_id = user_id
        self.is_logged_in = False
        self.last_scan_time: Optional[datetime.datetime] = None
        self.login_time: Optional[datetime.datetime] = None
        self.logout_time: Optional[datetime.datetime] = None
        self.status = AttendanceStatus.ABSENT

class RFIDAttendanceSystem:
    def __init__(self):
        self.schedule = AttendanceSchedule()
        self.sessions: Dict[str, UserSession] = {}
        self.attendance_logs: List[Dict] = []
        self.excused_users: Dict[str, datetime.date] = {}  # user_id -> date
        
    def add_excuse(self, user_id: str, date: datetime.date, reason: str = ""):
        """Add excuse for a user on specific date"""
        self.excused_users[f"{user_id}_{date}"] = {
            'date': date,
            'reason': reason,
            'added_at': datetime.datetime.now()
        }
        logger.info(f"Excuse added for user {user_id} on {date}")

    def is_user_excused(self, user_id: str, date: datetime.date) -> bool:
        """Check if user is excused for given date"""
        return f"{user_id}_{date}" in self.excused_users

    def get_user_session(self, user_id: str) -> UserSession:
        """Get or create user session"""
        if user_id not in self.sessions:
            self.sessions[user_id] = UserSession(user_id)
        return self.sessions[user_id]

    def calculate_time_difference_minutes(self, time1: datetime.time, time2: datetime.time) -> int:
        """Calculate difference between two times in minutes"""
        dt1 = datetime.datetime.combine(datetime.date.today(), time1)
        dt2 = datetime.datetime.combine(datetime.date.today(), time2)
        return int((dt2 - dt1).total_seconds() / 60)

    def determine_attendance_status(self, scan_time: datetime.datetime, is_login: bool) -> AttendanceStatus:
        """Determine attendance status based on scan time"""
        scan_time_only = scan_time.time()
        scan_date = scan_time.date()
        
        # Check if user is excused
        user_id = getattr(scan_time, 'user_id', None)  # This would be passed separately
        if user_id and self.is_user_excused(user_id, scan_date):
            return AttendanceStatus.EXCUSE
            
        if not is_login:
            return AttendanceStatus.TIMEOUT
            
        # Calculate how late the user is
        if scan_time_only <= self.schedule.work_start:
            return AttendanceStatus.PRESENT
        
        minutes_late = self.calculate_time_difference_minutes(self.schedule.work_start, scan_time_only)
        
        if minutes_late <= self.schedule.late_threshold:
            return AttendanceStatus.LATE
        elif minutes_late <= self.schedule.so_late_threshold:
            return AttendanceStatus.SO_LATE
        else:
            return AttendanceStatus.ABSENT  # Too late, marked as absent

    def validate_scan_timing(self, user_session: UserSession, current_time: datetime.datetime) -> Tuple[bool, str]:
        """Validate if scan timing is appropriate"""
        if user_session.last_scan_time is None:
            return True, "First scan of the day"
            
        time_diff = (current_time - user_session.last_scan_time).total_seconds() / 60
        
        # If user is logged in and trying to scan again too soon
        if user_session.is_logged_in and time_diff < self.schedule.timeout_duration:
            remaining_time = self.schedule.timeout_duration - time_diff
            return False, f"User already logged in. Next scan allowed in {remaining_time:.1f} minutes"
            
        # If user is logged out and trying to scan again too soon
        if not user_session.is_logged_in and time_diff < self.schedule.grace_period:
            return False, f"Too frequent scanning. Wait {self.schedule.grace_period - time_diff:.1f} minutes"
            
        return True, "Scan timing valid"

    def process_rfid_scan(self, user_id: str, scan_time: datetime.datetime = None) -> Dict:
        """Process RFID scan and return result"""
        if scan_time is None:
            scan_time = datetime.datetime.now()
            
        try:
            # Input validation
            if not user_id or not isinstance(user_id, str):
                raise RFIDLogError("Invalid user ID provided")
                
            user_session = self.get_user_session(user_id)
            
            # Validate scan timing
            timing_valid, timing_message = self.validate_scan_timing(user_session, scan_time)
            if not timing_valid:
                logger.warning(f"Scan rejected for user {user_id}: {timing_message}")
                return {
                    'success': False,
                    'error': 'TIMING_ERROR',
                    'message': timing_message,
                    'user_id': user_id,
                    'scan_time': scan_time.isoformat(),
                    'current_status': user_session.status.value
                }
            
            # Determine if this is login or logout
            is_login = not user_session.is_logged_in
            
            # Calculate attendance status
            scan_time.user_id = user_id  # Temporary assignment for status calculation
            attendance_status = self.determine_attendance_status(scan_time, is_login)
            
            # Process the scan
            if is_login:
                user_session.is_logged_in = True
                user_session.login_time = scan_time
                user_session.logout_time = None
                action = "LOGIN"
            else:
                user_session.is_logged_in = False
                user_session.logout_time = scan_time
                action = "LOGOUT"
                # For logout, we keep the login status, don't change to timeout
                if attendance_status == AttendanceStatus.TIMEOUT:
                    attendance_status = user_session.status
            
            user_session.last_scan_time = scan_time
            user_session.status = attendance_status
            
            # Create log entry
            log_entry = {
                'user_id': user_id,
                'scan_time': scan_time.isoformat(),
                'action': action,
                'status': attendance_status.value,
                'is_logged_in': user_session.is_logged_in,
                'login_time': user_session.login_time.isoformat() if user_session.login_time else None,
                'logout_time': user_session.logout_time.isoformat() if user_session.logout_time else None
            }
            
            self.attendance_logs.append(log_entry)
            
            logger.info(f"Scan processed - User: {user_id}, Action: {action}, Status: {attendance_status.value}")
            
            return {
                'success': True,
                'user_id': user_id,
                'action': action,
                'status': attendance_status.value,
                'scan_time': scan_time.isoformat(),
                'message': f"Scan successful - {action}",
                'is_logged_in': user_session.is_logged_in
            }
            
        except RFIDLogError as e:
            logger.error(f"RFID Log Error for user {user_id}: {str(e)}")
            return {
                'success': False,
                'error': 'RFID_ERROR',
                'message': str(e),
                'user_id': user_id,
                'scan_time': scan_time.isoformat() if scan_time else None
            }
        except Exception as e:
            logger.error(f"Unexpected error processing scan for user {user_id}: {str(e)}")
            return {
                'success': False,
                'error': 'SYSTEM_ERROR',
                'message': 'System error occurred',
                'user_id': user_id,
                'scan_time': scan_time.isoformat() if scan_time else None
            }

    def get_user_status(self, user_id: str) -> Dict:
        """Get current status of a user"""
        if user_id not in self.sessions:
            return {
                'user_id': user_id,
                'is_logged_in': False,
                'status': AttendanceStatus.ABSENT.value,
                'last_scan_time': None
            }
            
        session = self.sessions[user_id]
        return {
            'user_id': user_id,
            'is_logged_in': session.is_logged_in,
            'status': session.status.value,
            'last_scan_time': session.last_scan_time.isoformat() if session.last_scan_time else None,
            'login_time': session.login_time.isoformat() if session.login_time else None,
            'logout_time': session.logout_time.isoformat() if session.logout_time else None
        }

    def get_daily_report(self, date: datetime.date = None) -> Dict:
        """Generate daily attendance report"""
        if date is None:
            date = datetime.date.today()
            
        daily_logs = [
            log for log in self.attendance_logs 
            if datetime.datetime.fromisoformat(log['scan_time']).date() == date
        ]
        
        status_count = {status.value: 0 for status in AttendanceStatus}
        for log in daily_logs:
            if log['action'] == 'LOGIN':  # Only count login actions for status
                status_count[log['status']] += 1
        
        return {
            'date': date.isoformat(),
            'total_scans': len(daily_logs),
            'unique_users': len(set(log['user_id'] for log in daily_logs)),
            'status_breakdown': status_count,
            'logs': daily_logs
        }

    def reset_daily_sessions(self):
        """Reset all user sessions (typically called at end of day)"""
        for session in self.sessions.values():
            session.is_logged_in = False
            session.last_scan_time = None
            session.login_time = None
            session.logout_time = None
            session.status = AttendanceStatus.ABSENT
        logger.info("All user sessions reset")

# Example usage and testing
def main():
    # Initialize the system
    rfid_system = RFIDAttendanceSystem()
    
    print("=== RFID Attendance System Demo ===\n")
    
    # Test scenarios
    current_time = datetime.datetime.now().replace(hour=8, minute=30)  # 8:30 AM
    
    # Scenario 1: Normal login (late)
    print("1. User EMP001 scanning at 8:30 AM (late)")
    result = rfid_system.process_rfid_scan("EMP001", current_time)
    print(f"Result: {json.dumps(result, indent=2)}\n")
    
    # Scenario 2: Same user trying to scan again immediately (should fail)
    print("2. Same user trying to scan again immediately")
    result = rfid_system.process_rfid_scan("EMP001", current_time + datetime.timedelta(minutes=1))
    print(f"Result: {json.dumps(result, indent=2)}\n")
    
    # Scenario 3: User logout after timeout period
    print("3. User EMP001 logout after 35 minutes")
    logout_time = current_time + datetime.timedelta(minutes=35)
    result = rfid_system.process_rfid_scan("EMP001", logout_time)
    print(f"Result: {json.dumps(result, indent=2)}\n")
    
    # Scenario 4: Very late user
    print("4. User EMP002 scanning at 10:00 AM (very late)")
    late_time = datetime.datetime.now().replace(hour=10, minute=0)
    result = rfid_system.process_rfid_scan("EMP002", late_time)
    print(f"Result: {json.dumps(result, indent=2)}\n")
    
    # Scenario 5: Excused user
    print("5. Adding excuse for EMP003 and testing scan")
    rfid_system.add_excuse("EMP003", datetime.date.today(), "Medical appointment")
    excuse_time = datetime.datetime.now().replace(hour=9, minute=30)
    result = rfid_system.process_rfid_scan("EMP003", excuse_time)
    print(f"Result: {json.dumps(result, indent=2)}\n")
    
    # Generate daily report
    print("6. Daily Report")
    report = rfid_system.get_daily_report()
    print(f"Report: {json.dumps(report, indent=2)}")

if __name__ == "__main__":
    main()